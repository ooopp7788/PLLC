#### 回到问题证明 evalr 是一个函数
现在我们有了结构归纳法，我们准备回到第一章的问题，`evalr` 作为一个求值器的一致性
也就是证明 `evalr` 是一个函数
定义 evalr 的结果 R
```BNF
R = t
  | f
```

#### 定理3.1: 一致性证明
如果 evalr(B0) = R1 且 evalr(B0) = R2, 那么 R1 = R2
用关系式表示:
B0  =r  R1
B0  =r  R2

R1  =r  R2
为了得到结论 R1 = R2，我们必须学习`计算的本质`: 和 `M =r N (when M, N ∈ B)`的证明有着类似轮廓
类似下面的步骤(Li ∈ B)单次规约:
M   r  L1
L1  r  L2

L3  r  L2
L3  r  L4
...
<!-- L5  r  L4 -->
N   r  L5

用 `->>` 多次规约简化后:
M   ->>r   L
N   ->>r   L
如果可以证明总是存在 L 使上面成立，就证明了 M = N

假设定理3.2成立: 若 M =r N，则总是存在 L，使得 M ->>r L 且 N ->>r L
回到定理3.1的证明：
B0  =r  R1
B0  =r  R2
由于 =r 等价关系的性质，得: R1 =r R2
由定理 3.2 得，存在L，使得:
R1  ->>r  L
R2  ->>r  L
又由于 R 集合只包含 t | f，R无法规约为更简单的表达式（除了他们自己），所以 R1 = L, R2 = L
R1 = R2 得证

关于 正式求值系统的一致性证明 和 一系列规约步骤的重新排列之间 的联系，这个重大的发现是 Chruch 和 Rosser 提出的，他们用这个概念去分析一种叫做`λ-calculus`的语言的一致性

#### 定理3.2 Chruch-Rosser for =r
如果 M  =r  N，那么一定存在一个表达式 L ，使得 M ->>r L 且 N ->>r L
证明:
* Base case
    - Case: M  ->>r  N，M 可以直接规约到 N，令 L = N，定理成立
* Inductive cases:
    - Case: N  =r  M，原因是 N  =r  M（对称性）。由归纳得，存在 L
    - Case: N  =r  M，原因是 N  =r  L0 且 L0  =r  N（传递性）。`假设`(substruct成立)存在一个 L1 使得 M ->>r L1 且 `L0 ->>r L1`，同时L0 =r N 得存在一个 L2 使得 `L0 ->>r L2` 且 N ->>r L2。
      每当 L0  ->>  L1 且 L0  ->>  L2时，一定存在 L0 ->> L3，所以L1 ->> L3, L2 ->> L3。所以L3 即是 所需要的 L，使得 M ->> L, N ->> L。
由于定理3.2用图案表示出来是一个菱形（钻石形状），所以这类性质由称之为钻石性质

#### 定理3.3 ->>r 的钻石性质


#### 定理3.4 ->r 的钻石性质